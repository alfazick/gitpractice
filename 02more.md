
## 1) Tracking of changes ##
For each commit, Git generates a SHA-1 hash as the commit identifier. 

The hash is based on the current time, the author, the parent commit ID, and some other information.

The commit hash is generated by Git automatically. We get a new hash each time.


a) git status keeps track of (untracked, tracked, staged) 

b) git log  commited

Git don't keep track of folders, to start to keep empty folders
you can create empty .gitkeep file

## 2) Branches

a) Create a Branch

```
$ git switch -c new_feature
```

git switches to a new branch

# Exercise

a) Run the following commands in the terminal:

```
$ git switch -c new_feature
```

b) Create some files.
```
$ touch new_feature_branch.py
```

c) Run the git add . command.
```
$ git add new_feature_branch.py
```

d) Run the following git commit command:
```
$ git commit -m "First commit in new_feature branch."
```

e) Run the git log command.
```
$ git log
```

f) Go back to the master branch.
```
$ git switch master
```

g) Make changes in master.
```
$ touch new_feature_main.py
$ git add new_feature_main.py
$ git commit -m "Make changes in master."
```

h) Run the git log command again.
```
$ git log --oneline --graph --decorate --all
```

Note:
For older version of git

We can use git checkout branch_name to switch between branches and 
git checkout -b new_branch_name to create a new branch


## 3 Merge Branches Simple

Step 1: Switch to the Target Branch (main)
Before merging, make sure you are on the branch that you want to update. In this case, you want to merge changes into the main branch, so you should switch to main first.

Command:

```
git checkout main
```

Or, if youâ€™re using a newer version of Git:

```
git switch main
```

Explanation:
These commands change your current working branch to main. 
This is important because Git merges changes into the current branch.

Step 2: Merge Changes from new_feature
Now, merge the new_feature branch into your currently active branch (main).

```
git merge new_feature
```

Explanation:
This command brings all the commits from new_feature into main. If new_feature has any commits that main does not yet have, they will be applied in order.

## 4 The git diff Command

a) Basic Usage
Working Directory vs Staging Area: Shows changes in your working directory that are not yet staged.
```
git diff
```
b) Comparing Staged Changes
Staging Area vs Last Commit: Displays differences between staged changes and the last commit.
```
git diff --staged
```
or

```
git diff --cached  # Equivalent to --staged
```
c) Comparing Branches
Between Branches: Shows differences between the tips of two branches.
```
git diff branch1..branch2```

d) Comparing Commits
Specific Commits: Compare the changes between two specific commits.
```
git diff commit1 commit2
```

Practical Example Using git diff
Consider you have made changes across several files and you want to review the differences before committing:

Create and modify files:
```
echo "Initial content" > example.txt
git add example.txt
echo "More changes" >> example.txt
```

View Changes:
```
git diff  # Shows changes in 'example.txt' that are not yet staged
```

Stage and Commit:
```
git add .
git commit -m "Initial commit"
echo "Additional post-commit changes" >> example.txt
```

View Staged Changes vs Last Commit:

```
git add example.txt
git diff --staged
```
This command line interaction illustrates how to track changes at each step, ensuring you understand what will be included in each commit.

Overall, git diff is a versatile tool for examining changes in your Git repository, allowing for careful tracking and management of your codebase.

